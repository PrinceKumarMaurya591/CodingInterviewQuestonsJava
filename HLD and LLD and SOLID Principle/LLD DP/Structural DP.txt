List of Structural Design Patterns (with Steps, Pseudocode, Use Case)
Pattern	Purpose
1. Adapter	Convert one interface into another expected by the client.
2. Bridge	Separate abstraction from implementation for flexibility.
3. Composite	Treat individual objects and groups uniformly (tree structures).
4. Decorator	Add responsibilities to objects dynamically.
5. Facade	Provide a unified interface to a set of subsystems.
6. Flyweight	Share objects to support large numbers efficiently.
7. Proxy	Provide a placeholder or surrogate to control access.

âœ… 1. Adapter Pattern
ðŸ“Œ Goal:
Match interfaces that are incompatible.

âœ… Steps:
Create the target interface expected by the client.

Create the adaptee class with a different interface.

Create an adapter class that implements the target interface and internally uses the adaptee.

ðŸ”¢ Pseudocode:
java
Copy
Edit
interface Target {
    void request();
}

class Adaptee {
    void specificRequest() { ... }
}

class Adapter implements Target {
    private Adaptee adaptee;

    public Adapter(Adaptee adaptee) { this.adaptee = adaptee; }

    public void request() {
        adaptee.specificRequest(); // convert call
    }
}
âœ… 2. Bridge Pattern
ðŸ“Œ Goal:
Decouple abstraction from implementation.

âœ… Steps:
Define abstraction and implementation interfaces.

Implement concrete classes of both.

Bridge abstraction class delegates to the implementation.

ðŸ”¢ Pseudocode:
java
Copy
Edit
interface Device {
    void turnOn();
}

class TV implements Device {
    public void turnOn() { ... }
}

abstract class Remote {
    protected Device device;

    Remote(Device device) { this.device = device; }

    abstract void pressButton();
}

class AdvancedRemote extends Remote {
    void pressButton() {
        device.turnOn(); // bridge the call
    }
}
âœ… 3. Composite Pattern
ðŸ“Œ Goal:
Treat individual objects and compositions uniformly.

âœ… Steps:
Create a component interface.

Implement leaf and composite classes.

Composite class manages child components.

ðŸ”¢ Pseudocode:
java
Copy
Edit
interface Component {
    void showDetails();
}

class Leaf implements Component {
    public void showDetails() { ... }
}

class Composite implements Component {
    private List<Component> children = new ArrayList<>();

    void add(Component c) { children.add(c); }

    public void showDetails() {
        for (Component c : children) c.showDetails();
    }
}
âœ… 4. Decorator Pattern
ðŸ“Œ Goal:
Add responsibilities dynamically without modifying original class.

âœ… Steps:
Create a component interface.

Implement concrete component.

Create abstract decorator that wraps the component.

Add concrete decorators that extend functionality.

ðŸ”¢ Pseudocode:
java
Copy
Edit
interface Coffee {
    String getDescription();
    double getCost();
}

class SimpleCoffee implements Coffee {
    public String getDescription() { return "Simple Coffee"; }
    public double getCost() { return 5; }
}

class MilkDecorator implements Coffee {
    private Coffee coffee;
    public MilkDecorator(Coffee c) { this.coffee = c; }

    public String getDescription() {
        return coffee.getDescription() + ", Milk";
    }

    public double getCost() {
        return coffee.getCost() + 1.5;
    }
}
âœ… 5. Facade Pattern
ðŸ“Œ Goal:
Simplify usage of a complex system by providing a single interface.

âœ… Steps:
Identify complex subsystems.

Create a Facade class that wraps and delegates to them.

Client uses the facade instead of subsystems directly.

ðŸ”¢ Pseudocode:
java
Copy
Edit
class CPU { void start() { ... } }
class Memory { void load() { ... } }
class Disk { void read() { ... } }

class ComputerFacade {
    private CPU cpu = new CPU();
    private Memory memory = new Memory();
    private Disk disk = new Disk();

    void startComputer() {
        cpu.start();
        memory.load();
        disk.read();
    }
}
âœ… 6. Flyweight Pattern
ðŸ“Œ Goal:
Minimize memory by sharing as much data as possible.

âœ… Steps:
Create a shared object class.

Create a factory to manage instances.

Reuse objects with same data instead of creating new.

ðŸ”¢ Pseudocode:
java
Copy
Edit
class Circle {
    private String color; // intrinsic (shared)
    private int x, y, radius; // extrinsic

    public void draw() { ... }
}

class CircleFactory {
    private Map<String, Circle> circleMap = new HashMap<>();

    public Circle getCircle(String color) {
        if (!circleMap.containsKey(color)) {
            circleMap.put(color, new Circle(color));
        }
        return circleMap.get(color);
    }
}
âœ… 7. Proxy Pattern
ðŸ“Œ Goal:
Provide a placeholder for another object to control access.

âœ… Steps:
Define a subject interface.

Create the real object.

Create the proxy object that controls access to the real one.

ðŸ”¢ Pseudocode:
java
Copy
Edit
interface Service {
    void request();
}

class RealService implements Service {
    public void request() { ... }
}

class ProxyService implements Service {
    private RealService realService;

    public void request() {
        if (realService == null)
            realService = new RealService();
        // control access, log, cache, etc.
        realService.request();
    }
}
âœ… Summary Table
Pattern	Key Idea	Use Case
Adapter	Convert interface	Legacy system integration
Bridge	Separate abstraction & implementation	Multiple dimensions of variation
Composite	Tree structure	GUI menus, file system
Decorator	Add features dynamically	Adding toppings to a pizza
Facade	Simplify complex subsystem	Library APIs, startup/shutdown code
Flyweight	Share object state	Rendering 1,000+ similar objects
Proxy	Control access	Security, lazy loading, logging